{"transactions":{"add_to_nft_catalog":"import MetadataViews from 0xMetadataViews\nimport NFTCatalog from 0xNFTCatalog\nimport NFTCatalogAdmin from 0xNFTCatalogAdmin\n\ntransaction(\n  collectionName : String,\n  contractName: String,\n  contractAddress: Address,\n  nftTypeIdentifer: String,\n  addressWithNFT: Address,\n  publicPathIdentifier: String\n) {\n  let adminProxyResource : &NFTCatalogAdmin.AdminProxy\n\n  prepare(acct: AuthAccount) {\n    self.adminProxyResource = acct.borrow<&NFTCatalogAdmin.AdminProxy>(from : NFTCatalogAdmin.AdminProxyStoragePath)!\n  }\n\n  execute {\n    let nftAccount = getAccount(addressWithNFT)\n    let pubPath = PublicPath(identifier: publicPathIdentifier)!\n    let collectionCap = nftAccount.getCapability<&AnyResource{MetadataViews.ResolverCollection}>(pubPath)\n    assert(collectionCap.check(), message: \"MetadataViews Collection is not set up properly, ensure the Capability was created/linked correctly.\")\n    let collectionRef = collectionCap.borrow()!\n    assert(collectionRef.getIDs().length > 0, message: \"No NFTs exist in this collection, ensure the provided account has at least 1 NFTs.\")\n    let testNftId = collectionRef.getIDs()[0]\n    let nftResolver = collectionRef.borrowViewResolver(id: testNftId)\n    \n    let metadataCollectionData = nftResolver.resolveView(Type<MetadataViews.NFTCollectionData>())! as! MetadataViews.NFTCollectionData\n    \n    let collectionData = NFTCatalog.NFTCollectionData(\n      storagePath: metadataCollectionData.storagePath,\n      publicPath: metadataCollectionData.publicPath,\n      privatePath: metadataCollectionData.providerPath,\n      publicLinkedType : metadataCollectionData.publicLinkedType,\n      privateLinkedType : metadataCollectionData.providerLinkedType\n    )\n\n    let collectionDisplay = nftResolver.resolveView(Type<MetadataViews.NFTCollectionDisplay>())! as! MetadataViews.NFTCollectionDisplay\n\n    let catalogData = NFTCatalog.NFTCatalogMetadata(\n      contractName: contractName,\n      contractAddress: contractAddress,\n      nftType: CompositeType(nftTypeIdentifer)!,\n      collectionData: collectionData,\n      collectionDisplay : collectionDisplay\n    )\n    \n    self.adminProxyResource.getCapability()!.borrow()!.addCatalogEntry(collectionName : collectionName, metadata : catalogData)\n  }\n}","add_to_nft_catalog_admin":"import MetadataViews from 0xMetadataViews\nimport NFTCatalog from 0xNFTCatalog\nimport NFTCatalogAdmin from 0xNFTCatalogAdmin\n\ntransaction(\n  collectionName : String,\n  contractName: String,\n  contractAddress: Address,\n  nftTypeIdentifer: String,\n  addressWithNFT: Address,\n  publicPathIdentifier: String\n) {\n  \n  let adminResource: &NFTCatalogAdmin.Admin\n  \n  prepare(acct: AuthAccount) {\n    self.adminResource = acct.borrow<&NFTCatalogAdmin.Admin>(from: NFTCatalogAdmin.AdminStoragePath)!\n  }\n  \n  execute {\n    let nftAccount = getAccount(addressWithNFT)\n    let pubPath = PublicPath(identifier: publicPathIdentifier)!\n    let collectionCap = nftAccount.getCapability<&AnyResource{MetadataViews.ResolverCollection}>(pubPath)\n    assert(collectionCap.check(), message: \"MetadataViews Collection is not set up properly, ensure the Capability was created/linked correctly.\")\n    let collectionRef = collectionCap.borrow()!\n    assert(collectionRef.getIDs().length > 0, message: \"No NFTs exist in this collection, ensure the provided account has at least 1 NFTs.\")\n    let testNftId = collectionRef.getIDs()[0]\n    let nftResolver = collectionRef.borrowViewResolver(id: testNftId)\n    \n    let metadataCollectionData = nftResolver.resolveView(Type<MetadataViews.NFTCollectionData>())! as! MetadataViews.NFTCollectionData\n    \n    let collectionData = NFTCatalog.NFTCollectionData(\n      storagePath: metadataCollectionData.storagePath,\n      publicPath: metadataCollectionData.publicPath,\n      privatePath: metadataCollectionData.providerPath,\n      publicLinkedType : metadataCollectionData.publicLinkedType,\n      privateLinkedType : metadataCollectionData.providerLinkedType\n    )\n\n    let collectionDisplay = nftResolver.resolveView(Type<MetadataViews.NFTCollectionDisplay>())! as! MetadataViews.NFTCollectionDisplay\n\n    let catalogData = NFTCatalog.NFTCatalogMetadata(\n      contractName: contractName,\n      contractAddress: contractAddress,\n      nftType: CompositeType(nftTypeIdentifer)!,\n      collectionData: collectionData,\n      collectionDisplay : collectionDisplay\n    )\n\n    self.adminResource.addCatalogEntry(collectionName : collectionName, metadata : catalogData)\n  }\n}","approve_nft_catalog_proposal":"import NFTCatalogAdmin from 0xNFTCatalogAdmin\n\ntransaction(proposalID : UInt64) {\n  let adminProxyResource : &NFTCatalogAdmin.AdminProxy\n\n  prepare(acct: AuthAccount) {\n    self.adminProxyResource = acct.borrow<&NFTCatalogAdmin.AdminProxy>(from : NFTCatalogAdmin.AdminProxyStoragePath)!\n  }\n\n  execute {\n    self.adminProxyResource.getCapability()!.borrow()!.approveCatalogProposal(proposalID : proposalID)\n  }\n}","mint_example_nft":"import NonFungibleToken from 0xNonFungibleToken\nimport ExampleNFT from 0xExampleNFT\nimport MetadataViews from 0xMetadataViews\nimport FungibleToken from 0xFungibleToken\n\n// This script uses the NFTMinter resource to mint a new NFT\n// It must be run with the account that has the minter resource\n// stored in /storage/NFTMinter\n\ntransaction(\n    recipient: Address,\n    name: String,\n    description: String,\n    thumbnail: String,\n    cuts: [UFix64],\n    royaltyDescriptions: [String],\n    royaltyBeneficiaries: [Address]\n) {\n\n    // local variable for storing the minter reference\n    let minter: &ExampleNFT.NFTMinter\n\n    let royalties: [MetadataViews.Royalty]\n\n\n    prepare(signer: AuthAccount) {\n        // borrow a reference to the NFTMinter resource in storage\n        self.minter = signer.borrow<&ExampleNFT.NFTMinter>(from: ExampleNFT.MinterStoragePath)\n            ?? panic(\"Could not borrow a reference to the NFT minter\")\n        \n        // creating the royalty details\n        var count = 0\n        self.royalties = []\n        while royaltyBeneficiaries.length > count {\n            let beneficiary = royaltyBeneficiaries[count]\n            let beneficiaryCapability = getAccount(beneficiary)\n            .getCapability<&{FungibleToken.Receiver}>(MetadataViews.getRoyaltyReceiverPublicPath())\n\n            // Make sure the royalty capability is valid before minting the NFT\n            if !beneficiaryCapability.check() { panic(\"Beneficiary capability is not valid!\") }\n\n            self.royalties.append(\n                MetadataViews.Royalty(\n                    receiver: beneficiaryCapability,\n                    cut: cuts[count],\n                    description: royaltyDescriptions[count]\n                )\n            )\n            count = count + 1\n        }\n    }\n\n    pre {\n        cuts.length == royaltyDescriptions.length && cuts.length == royaltyBeneficiaries.length: \"Array length should be equal for royalty related details\"\n    }\n\n    execute {\n        // Borrow the recipient's public NFT collection reference\n        let receiver = getAccount(recipient)\n            .getCapability(ExampleNFT.CollectionPublicPath)\n            .borrow<&{NonFungibleToken.CollectionPublic}>()\n            ?? panic(\"Could not get receiver reference to the NFT Collection\")\n\n        // Mint the NFT and deposit it to the recipient's collection\n        self.minter.mintNFT(\n            recipient: receiver,\n            name: name,\n            description: description,\n            thumbnail: thumbnail,\n            royalties: self.royalties\n        )\n    }\n}\n ","propose_nft_to_catalog":"import MetadataViews from 0xMetadataViews\nimport NFTCatalog from 0xNFTCatalog\n\ntransaction(\n  collectionName : String,\n  contractName: String,\n  contractAddress: Address,\n  nftTypeIdentifer: String,\n  addressWithNFT: Address,\n  publicPathIdentifier: String,\n  message: String\n) {\n\n  let nftCatalogProposalResourceRef : &NFTCatalog.NFTCatalogProposalManager\n  \n  prepare(acct: AuthAccount) {\n    \n    if acct.borrow<&NFTCatalog.NFTCatalogProposalManager>(from: NFTCatalog.ProposalManagerStoragePath) == nil {\n       let proposalManager <- NFTCatalog.createNFTCatalogProposalManager()\n       acct.save(<-proposalManager, to: NFTCatalog.ProposalManagerStoragePath)\n       acct.link<&NFTCatalog.NFTCatalogProposalManager{NFTCatalog.NFTCatalogProposalManagerPublic}>(NFTCatalog.ProposalManagerPublicPath, target: NFTCatalog.ProposalManagerStoragePath)\n    }\n\n    self.nftCatalogProposalResourceRef = acct.borrow<&NFTCatalog.NFTCatalogProposalManager>(from: NFTCatalog.ProposalManagerStoragePath)!\n  }\n  \n  execute {\n    let nftAccount = getAccount(addressWithNFT)\n    let pubPath = PublicPath(identifier: publicPathIdentifier)!\n    let collectionCap = nftAccount.getCapability<&AnyResource{MetadataViews.ResolverCollection}>(pubPath)\n    assert(collectionCap.check(), message: \"MetadataViews Collection is not set up properly, ensure the Capability was created/linked correctly.\")\n    let collectionRef = collectionCap.borrow()!\n    assert(collectionRef.getIDs().length > 0, message: \"No NFTs exist in this collection, ensure the provided account has at least 1 NFTs.\")\n    let testNftId = collectionRef.getIDs()[0]\n    let nftResolver = collectionRef.borrowViewResolver(id: testNftId)\n    \n    let metadataCollectionData = nftResolver.resolveView(Type<MetadataViews.NFTCollectionData>())! as! MetadataViews.NFTCollectionData\n    \n    let collectionData = NFTCatalog.NFTCollectionData(\n      storagePath: metadataCollectionData.storagePath,\n      publicPath: metadataCollectionData.publicPath,\n      privatePath: metadataCollectionData.providerPath,\n      publicLinkedType : metadataCollectionData.publicLinkedType,\n      privateLinkedType : metadataCollectionData.providerLinkedType\n    )\n\n    let collectionDisplay = nftResolver.resolveView(Type<MetadataViews.NFTCollectionDisplay>())! as! MetadataViews.NFTCollectionDisplay\n\n    let catalogData = NFTCatalog.NFTCatalogMetadata(\n      contractName: contractName,\n      contractAddress: contractAddress,\n      nftType: CompositeType(nftTypeIdentifer)!,\n      collectionData: collectionData,\n      collectionDisplay : collectionDisplay\n    )\n\n    self.nftCatalogProposalResourceRef.setCurrentProposalEntry(name : collectionName)\n\n    NFTCatalog.proposeNFTMetadata(collectionName : collectionName, metadata : catalogData, message: message, proposer: self.nftCatalogProposalResourceRef.owner!.address)\n\n    self.nftCatalogProposalResourceRef.setCurrentProposalEntry(name : nil)\n  }\n}","reject_nft_catalog_proposal":"import NFTCatalogAdmin from 0xNFTCatalogAdmin\n\ntransaction(proposalID : UInt64) {\n  let adminProxyResource : &NFTCatalogAdmin.AdminProxy\n\n  prepare(acct: AuthAccount) {\n    self.adminProxyResource = acct.borrow<&NFTCatalogAdmin.AdminProxy>(from : NFTCatalogAdmin.AdminProxyStoragePath)!\n  }\n\n  execute {\n    self.adminProxyResource.getCapability()!.borrow()!.rejectCatalogProposal(proposalID : proposalID)\n  }\n}","remove_from_nft_catalog":"import MetadataViews from 0xMetadataViews\nimport NFTCatalog from 0xNFTCatalog\nimport NFTCatalogAdmin from 0xNFTCatalogAdmin\n\ntransaction(\n  collectionName : String\n) {\n  let adminProxyResource : &NFTCatalogAdmin.AdminProxy\n\n  prepare(acct: AuthAccount) {\n    self.adminProxyResource = acct.borrow<&NFTCatalogAdmin.AdminProxy>(from : NFTCatalogAdmin.AdminProxyStoragePath)!\n  }\n\n  execute {   \n    self.adminProxyResource.getCapability()!.borrow()!.removeCatalogEntry(collectionName : collectionName)\n  }\n}","remove_nft_catalog_proposal":"import NFTCatalogAdmin from 0xNFTCatalogAdmin\n\ntransaction(proposalID : UInt64) {\n  let adminProxyResource : &NFTCatalogAdmin.AdminProxy\n\n  prepare(acct: AuthAccount) {\n    self.adminProxyResource = acct.borrow<&NFTCatalogAdmin.AdminProxy>(from : NFTCatalogAdmin.AdminProxyStoragePath)!\n  }\n\n  execute {\n    self.adminProxyResource.getCapability()!.borrow()!.removeCatalogProposal(proposalID : proposalID)\n  }\n}","send_admin_capability_to_proxy":"import NFTCatalogAdmin from 0xNFTCatalogAdmin\n\ntransaction(proxyAddress: Address) {\n  let adminCap : Capability<&NFTCatalogAdmin.Admin>\n  \n  prepare(acct: AuthAccount) {\n    self.adminCap = acct.getCapability<&NFTCatalogAdmin.Admin>(NFTCatalogAdmin.AdminPrivatePath)\n  }\n\n  execute {\n    let owner = getAccount(proxyAddress)\n    let proxy = owner.getCapability<&{NFTCatalogAdmin.IAdminProxy}>(NFTCatalogAdmin.AdminProxyPublicPath)\n      .borrow() ?? panic(\"Could not borrow Admin Proxy\")\n    \n    proxy.addCapability(capability : self.adminCap)\n  }\n}","setup_examplenft_collection":"import NonFungibleToken from 0xNonFungibleToken\nimport ExampleNFT from 0xExampleNFT\nimport MetadataViews from 0xMetadataViews\n\n// This transaction is what an account would run\n// to set itself up to receive NFTs\n\ntransaction {\n\n    prepare(signer: AuthAccount) {\n        // Return early if the account already has a collection\n        if signer.borrow<&ExampleNFT.Collection>(from: ExampleNFT.CollectionStoragePath) != nil {\n            return\n        }\n\n        // Create a new empty collection\n        let collection <- ExampleNFT.createEmptyCollection()\n\n        // save it to the account\n        signer.save(<-collection, to: ExampleNFT.CollectionStoragePath)\n\n        // create a public capability for the collection\n        signer.link<&{NonFungibleToken.CollectionPublic, ExampleNFT.ExampleNFTCollectionPublic, MetadataViews.ResolverCollection}>(\n            ExampleNFT.CollectionPublicPath,\n            target: ExampleNFT.CollectionStoragePath\n        )\n    }\n}","setup_nft_catalog_admin_proxy":"import NFTCatalogAdmin from 0xNFTCatalogAdmin\n\ntransaction() {\n  \n  prepare(acct: AuthAccount) {\n    if acct.getCapability(NFTCatalogAdmin.AdminProxyPublicPath).check<&AnyResource>() {\n      acct.unlink(NFTCatalogAdmin.AdminProxyPublicPath)\n      destroy <- acct.load<@AnyResource>(from: NFTCatalogAdmin.AdminProxyStoragePath)\n    }\n\n    acct.save(<- NFTCatalogAdmin.createAdminProxy(), to: NFTCatalogAdmin.AdminProxyStoragePath)\n    acct.link<&{NFTCatalogAdmin.IAdminProxy}>(NFTCatalogAdmin.AdminProxyPublicPath, target: NFTCatalogAdmin.AdminProxyStoragePath)\n  }\n}","transfer_examplenft":"import NonFungibleToken from 0xNonFungibleToken\nimport ExampleNFT from 0xExampleNFT\n\n// This transaction is for transferring and NFT from\n// one account to another\n\ntransaction(recipient: Address, withdrawID: UInt64) {\n\n    prepare(signer: AuthAccount) {\n        // get the recipients public account object\n        let recipient = getAccount(recipient)\n\n        // borrow a reference to the signer's NFT collection\n        let collectionRef = signer\n            .borrow<&ExampleNFT.Collection>(from: ExampleNFT.CollectionStoragePath)\n            ?? panic(\"Could not borrow a reference to the owner's collection\")\n\n        // borrow a public reference to the receivers collection\n        let depositRef = recipient\n            .getCapability(ExampleNFT.CollectionPublicPath)\n            .borrow<&{NonFungibleToken.CollectionPublic}>()\n            ?? panic(\"Could not borrow a reference to the receiver's collection\")\n\n        // withdraw the NFT from the owner's collection\n        let nft <- collectionRef.withdraw(withdrawID: withdrawID)\n\n        // Deposit the NFT in the recipient's collection\n        depositRef.deposit(token: <-nft)\n    }\n}","update_nft_catalog_entry":"import MetadataViews from 0xMetadataViews\nimport NFTCatalog from 0xNFTCatalog\nimport NFTCatalogAdmin from 0xNFTCatalogAdmin\n\ntransaction(\n  collectionName : String,\n  contractName: String,\n  contractAddress: Address,\n  nftTypeIdentifer: String,\n  addressWithNFT: Address,\n  publicPathIdentifier: String\n) {\n  let adminProxyResource : &NFTCatalogAdmin.AdminProxy\n\n  prepare(acct: AuthAccount) {\n    self.adminProxyResource = acct.borrow<&NFTCatalogAdmin.AdminProxy>(from : NFTCatalogAdmin.AdminProxyStoragePath)!\n  }\n\n  execute {\n    let nftAccount = getAccount(addressWithNFT)\n    let pubPath = PublicPath(identifier: publicPathIdentifier)!\n    let collectionCap = nftAccount.getCapability<&AnyResource{MetadataViews.ResolverCollection}>(pubPath)\n    assert(collectionCap.check(), message: \"MetadataViews Collection is not set up properly, ensure the Capability was created/linked correctly.\")\n    let collectionRef = collectionCap.borrow()!\n    assert(collectionRef.getIDs().length > 0, message: \"No NFTs exist in this collection, ensure the provided account has at least 1 NFTs.\")\n    let testNftId = collectionRef.getIDs()[0]\n    let nftResolver = collectionRef.borrowViewResolver(id: testNftId)\n    \n    let metadataCollectionData = nftResolver.resolveView(Type<MetadataViews.NFTCollectionData>())! as! MetadataViews.NFTCollectionData\n    \n    let collectionData = NFTCatalog.NFTCollectionData(\n      storagePath: metadataCollectionData.storagePath,\n      publicPath: metadataCollectionData.publicPath,\n      privatePath: metadataCollectionData.providerPath,\n      publicLinkedType : metadataCollectionData.publicLinkedType,\n      privateLinkedType : metadataCollectionData.providerLinkedType\n    )\n\n    let collectionDisplay = nftResolver.resolveView(Type<MetadataViews.NFTCollectionDisplay>())! as! MetadataViews.NFTCollectionDisplay\n\n    let catalogData = NFTCatalog.NFTCatalogMetadata(\n      contractName: contractName,\n      contractAddress: contractAddress,\n      nftType: CompositeType(nftTypeIdentifer)!,\n      collectionData: collectionData,\n      collectionDisplay : collectionDisplay\n    )\n    \n    self.adminProxyResource.getCapability()!.borrow()!.updateCatalogEntry(collectionName : collectionName, metadata : catalogData)\n  }\n}","withdraw_nft_proposal_from_catalog":"import NFTCatalog from 0xNFTCatalog\n\ntransaction(\n  proposalID : UInt64\n) {\n  let nftCatalogProposalResourceRef : &NFTCatalog.NFTCatalogProposalManager\n\n  prepare(acct: AuthAccount) {\n    self.nftCatalogProposalResourceRef = acct.borrow<&NFTCatalog.NFTCatalogProposalManager>(from: NFTCatalog.ProposalManagerStoragePath)!\n  }\n\n  execute {\n    let proposal = NFTCatalog.getCatalogProposalEntry(proposalID: proposalID)!\n    \n    self.nftCatalogProposalResourceRef.setCurrentProposalEntry(name : proposal.collectionName)\n    NFTCatalog.withdrawNFTProposal(proposalID : proposalID)\n    self.nftCatalogProposalResourceRef.setCurrentProposalEntry(name : nil)\n  }\n}"},"scripts":{"get_all_nfts_in_account":"import MetadataViews from 0xMetadataViews\nimport NFTRetrieval from 0xNFTRetrieval\n\npub struct NFT {\n  pub let id : UInt64\n  pub let name : String\n  pub let description : String\n  pub let thumbnail : String\n  pub let externalURL : String\n  pub let storagePath : StoragePath\n  pub let publicPath : PublicPath\n  pub let privatePath: PrivatePath\n  pub let publicLinkedType: Type\n  pub let privateLinkedType: Type\n  pub let collectionName : String\n  pub let collectionDescription: String\n  pub let collectionSquareImage : String\n  pub let collectionBannerImage : String\n  pub let royalties: [MetadataViews.Royalty]\n\n  init(\n      id: UInt64,\n      name : String,\n      description : String,\n      thumbnail : String,\n      externalURL : String,\n      storagePath : StoragePath,\n      publicPath : PublicPath,\n      privatePath : PrivatePath,\n      publicLinkedType : Type,\n      privateLinkedType : Type,\n      collectionName : String,\n      collectionDescription : String,\n      collectionSquareImage : String,\n      collectionBannerImage : String,\n      royalties : [MetadataViews.Royalty]\n  ) {\n    self.id = id\n    self.name = name\n    self.description = description\n    self.thumbnail = thumbnail\n    self.externalURL = externalURL\n    self.storagePath = storagePath\n    self.publicPath = publicPath\n    self.privatePath = privatePath\n    self.publicLinkedType = publicLinkedType\n    self.privateLinkedType = privateLinkedType\n    self.collectionName = collectionName\n    self.collectionDescription = collectionDescription\n    self.collectionSquareImage = collectionSquareImage\n    self.collectionBannerImage = collectionBannerImage\n    self.royalties = royalties\n  }\n}\n\npub fun main(ownerAddress: Address) : { String : [NFT] } {\n  let nftCollections = NFTRetrieval.getNFTs(ownerAddress : ownerAddress)\n  let data : {String : [NFT] } = {}\n\n  for key in nftCollections.keys {\n    let nfts = nftCollections[key]!\n    let items : [NFT] = []\n    for nft in nfts {\n      let displayView = nft.display\n      let externalURLView = nft.externalURL\n      let collectionDataView = nft.collectionData\n      let collectionDisplayView = nft.collectionDisplay\n      let royaltyView = nft.royalties\n      if (displayView == nil || externalURLView == nil || collectionDataView == nil || collectionDisplayView == nil || royaltyView == nil) {\n        // Bad NFT. Skipping....\n        continue\n      }\n\n      items.append(\n        NFT(\n          id: nft.id,\n          name : displayView!.name,\n          description : displayView!.description,\n          thumbnail : displayView!.thumbnail.uri(),\n          externalURL : externalURLView!.url,\n          storagePath : collectionDataView!.storagePath,\n          publicPath : collectionDataView!.publicPath,\n          privatePath : collectionDataView!.providerPath,\n          publicLinkedType : collectionDataView!.publicLinkedType,\n          privateLinkedType : collectionDataView!.providerLinkedType,\n          collectionName : collectionDisplayView!.name,\n          collectionDescription : collectionDisplayView!.description,\n          collectionSquareImage : collectionDisplayView!.squareImage.file.uri(),\n          collectionBannerImage : collectionDisplayView!.bannerImage.file.uri(),\n          royalties : royaltyView!.getRoyalties()\n        )\n      )\n    }\n    data[key] = items\n  }\n  return data\n}\n","get_examplenft_collection_length":"import NonFungibleToken from 0xNonFungibleToken\nimport ExampleNFT from 0xExampleNFT\n\npub fun main(address: Address): Int {\n    let account = getAccount(address)\n\n    let collectionRef = account\n        .getCapability(ExampleNFT.CollectionPublicPath)\n        .borrow<&{NonFungibleToken.CollectionPublic}>()\n        ?? panic(\"Could not borrow capability from public collection\")\n    \n    return collectionRef.getIDs().length\n}","get_examplenft_type":"import NonFungibleToken from 0xNonFungibleToken\nimport ExampleNFT from 0xExampleNFT\n\npub fun main(): String {\n    return Type<@ExampleNFT.NFT>().identifier\n}","get_nft_catalog":"import NFTCatalog from 0xNFTCatalog\n\npub fun main(): {String : NFTCatalog.NFTCatalogMetadata} {\n  return NFTCatalog.getCatalog()\n}","get_nft_catalog_proposals":"import NFTCatalog from 0xNFTCatalog\n\npub fun main(): {UInt64 : NFTCatalog.NFTCatalogProposal} {\n  return NFTCatalog.getCatalogProposals()\n}","get_nft_collections_for_nft_type":"import NFTCatalog from 0xNFTCatalog\n\npub fun main(nftTypeIdentifer: String): {String : Bool}? {\n  return NFTCatalog.getCollectionsForType(nftTypeIdentifier: CompositeType(nftTypeIdentifer)!.identifier)\n}","get_nft_in_account":"import MetadataViews from 0xMetadataViews\nimport NFTRetrieval from 0xNFTRetrieval\n\npub struct NFT {\n  pub let id : UInt64\n  pub let name : String\n  pub let description : String\n  pub let thumbnail : String\n  pub let externalURL : String\n  pub let storagePath : StoragePath\n  pub let publicPath : PublicPath\n  pub let privatePath: PrivatePath\n  pub let publicLinkedType: Type\n  pub let privateLinkedType: Type\n  pub let collectionName : String\n  pub let collectionDescription: String\n  pub let collectionSquareImage : String\n  pub let collectionBannerImage : String\n  pub let royalties: [MetadataViews.Royalty]\n\n  init(\n      id: UInt64,\n      name : String,\n      description : String,\n      thumbnail : String,\n      externalURL : String,\n      storagePath : StoragePath,\n      publicPath : PublicPath,\n      privatePath : PrivatePath,\n      publicLinkedType : Type,\n      privateLinkedType : Type,\n      collectionName : String,\n      collectionDescription : String,\n      collectionSquareImage : String,\n      collectionBannerImage : String,\n      royalties : [MetadataViews.Royalty]\n  ) {\n    self.id = id\n    self.name = name\n    self.description = description\n    self.thumbnail = thumbnail\n    self.externalURL = externalURL\n    self.storagePath = storagePath\n    self.publicPath = publicPath\n    self.privatePath = privatePath\n    self.publicLinkedType = publicLinkedType\n    self.privateLinkedType = privateLinkedType\n    self.collectionName = collectionName\n    self.collectionDescription = collectionDescription\n    self.collectionSquareImage = collectionSquareImage\n    self.collectionBannerImage = collectionBannerImage\n    self.royalties = royalties\n  }\n}\n\npub fun main(ownerAddress: Address, collection : String, tokenID: UInt64) : NFT? {\n    let nftCollections = NFTRetrieval.getNFTs(ownerAddress : ownerAddress)\n\n    assert(nftCollections.containsKey(collection), message: \"Invalid Collection\")\n    \n    let nfts = nftCollections[collection]!\n    \n    for nft in nfts {\n      if nft.id == tokenID {\n        let displayView = nft.display\n        let externalURLView = nft.externalURL\n        let collectionDataView = nft.collectionData\n        let collectionDisplayView = nft.collectionDisplay\n        let royaltyView = nft.royalties\n        if (displayView == nil || externalURLView == nil || collectionDataView == nil || collectionDisplayView == nil || royaltyView == nil) {\n          // Bad NFT. Skipping....\n          return nil\n        }\n        return NFT(\n          id: nft.id,\n          name : displayView!.name,\n          description : displayView!.description,\n          thumbnail : displayView!.thumbnail.uri(),\n          externalURL : externalURLView!.url,\n          storagePath : collectionDataView!.storagePath,\n          publicPath : collectionDataView!.publicPath,\n          privatePath : collectionDataView!.providerPath,\n          publicLinkedType : collectionDataView!.publicLinkedType,\n          privateLinkedType : collectionDataView!.providerLinkedType,\n          collectionName : collectionDisplayView!.name,\n          collectionDescription : collectionDisplayView!.description,\n          collectionSquareImage : collectionDisplayView!.squareImage.file.uri(),\n          collectionBannerImage : collectionDisplayView!.bannerImage.file.uri(),\n          royalties : royaltyView!.getRoyalties()\n        )\n      }\n    }\n    panic(\"Invalid Token ID\")\n}","get_nft_in_account_from_path":"import MetadataViews from 0xMetadataViews\nimport NFTRetrieval from 0xNFTRetrieval\n\npub struct DisplayView {\n  pub let name : String\n  pub let description : String\n  pub let thumbnail : String\n\n  init (\n    name : String,\n    description : String,\n    thumbnail : String,\n  ) {\n    self.name = name\n    self.description = description\n    self.thumbnail = thumbnail\n  }\n}\n\npub struct ExternalURLView {\n  pub let externalURL : String\n\n  init (\n    externalURL : String\n  ) {\n    self.externalURL = externalURL\n  }\n}\n\npub struct NFTCollectionDataView {\n  pub let storagePath : StoragePath\n  pub let publicPath : PublicPath\n  pub let privatePath: PrivatePath\n  pub let publicLinkedType: Type\n  pub let privateLinkedType: Type\n\n  init (\n    storagePath : StoragePath,\n    publicPath : PublicPath,\n    privatePath : PrivatePath,\n    publicLinkedType : Type,\n    privateLinkedType : Type,\n  ) {\n    self.storagePath = storagePath\n    self.publicPath = publicPath\n    self.privatePath = privatePath\n    self.publicLinkedType = publicLinkedType\n    self.privateLinkedType = privateLinkedType\n  }\n}\n\npub struct NFTCollectionDisplayView {\n  pub let collectionName : String\n  pub let collectionDescription: String\n  pub let collectionSquareImage : String\n  pub let collectionBannerImage : String\n\n  init (\n    collectionName : String,\n    collectionDescription : String,\n    collectionSquareImage : String,\n    collectionBannerImage : String,\n  ) {\n    self.collectionName = collectionName\n    self.collectionDescription = collectionDescription\n    self.collectionSquareImage = collectionSquareImage\n    self.collectionBannerImage = collectionBannerImage\n  }\n}\n\npub struct RoyaltiesView {\n  pub let royalties: [MetadataViews.Royalty]\n\n  init (\n    royalties : [MetadataViews.Royalty]\n  ) {\n    self.royalties = royalties\n  }\n}\n\npub struct NFT {\n  pub let id : UInt64\n  pub let display : DisplayView?\n  pub let externalURL : ExternalURLView?\n  pub let nftCollectionData : NFTCollectionDataView?\n  pub let nftCollectionDisplay : NFTCollectionDisplayView?\n  pub let royalties : RoyaltiesView?\n\n  init(\n      id: UInt64,\n      display : DisplayView?,\n      externalURL : ExternalURLView?,\n      nftCollectionData : NFTCollectionDataView?,\n      nftCollectionDisplay : NFTCollectionDisplayView?,\n      royalties : RoyaltiesView?\n  ) {\n    self.id = id\n    self.display = display\n    self.externalURL = externalURL\n    self.nftCollectionData = nftCollectionData\n    self.nftCollectionDisplay = nftCollectionDisplay\n    self.royalties = royalties\n}\n\npub fun getMapping() : {String : AnyStruct} {\n  return {\n    \"Display\" : self.display,\n    \"ExternalURL\" : self.externalURL,\n    \"NFTCollectionData\" : self.nftCollectionData,\n    \"NFTCollectionDisplay\" : self.nftCollectionDisplay,\n    \"Royalties\" : self.royalties\n  }\n}\n\n}\n\npub fun main(ownerAddress: Address, publicPathIdentifier: String): {String : AnyStruct}  {\n  let owner = getAccount(ownerAddress)\n  let collectionCap = owner.getCapability<&AnyResource{MetadataViews.ResolverCollection}>(PublicPath(identifier: publicPathIdentifier)!)\n  assert(collectionCap.check(), message: \"MetadataViews Collection is not set up properly, ensure the Capability was created/linked correctly.\")\n  let collection = collectionCap.borrow()!\n  assert(collection.getIDs().length > 0, message: \"No NFTs exist in this collection, ensure the provided account has at least 1 NFTs.\")\n  let testNftId = collection.getIDs()[0]\n  let nftResolver = collection.borrowViewResolver(id: testNftId)\n  let nftViews = NFTRetrieval.BaseNFTViewsV1(\n    id : testNftId,\n    display: nftResolver.resolveView(Type<MetadataViews.Display>()) as! MetadataViews.Display?,\n    externalURL : nftResolver.resolveView(Type<MetadataViews.ExternalURL>()) as! MetadataViews.ExternalURL?,\n    collectionData : nftResolver.resolveView(Type<MetadataViews.NFTCollectionData>()) as! MetadataViews.NFTCollectionData?,\n    collectionDisplay : nftResolver.resolveView(Type<MetadataViews.NFTCollectionDisplay>()) as! MetadataViews.NFTCollectionDisplay?,\n    royalties : nftResolver.resolveView(Type<MetadataViews.Royalties>()) as! MetadataViews.Royalties?\n  )\n\n  let displayView = nftViews.display\n  let externalURLView = nftViews.externalURL\n  let collectionDataView = nftViews.collectionData\n  let collectionDisplayView = nftViews.collectionDisplay\n  let royaltyView = nftViews.royalties\n\n  var display : DisplayView? = nil\n  if displayView != nil {\n    display = DisplayView(\n      name : displayView!.name,\n      description : displayView!.description,\n      thumbnail : displayView!.thumbnail.uri()\n    )\n  }\n\n  var externalURL : ExternalURLView? = nil\n  if externalURLView != nil {\n    externalURL = ExternalURLView(\n      externalURL : externalURLView!.url,\n    )\n  }\n\n  var nftCollectionData : NFTCollectionDataView? = nil\n  if collectionDataView != nil {\n    nftCollectionData = NFTCollectionDataView(\n      storagePath : collectionDataView!.storagePath,\n      publicPath : collectionDataView!.publicPath,\n      privatePath : collectionDataView!.providerPath,\n      publicLinkedType : collectionDataView!.publicLinkedType,\n      privateLinkedType : collectionDataView!.providerLinkedType,\n    )\n  }\n\n  var nftCollectionDisplay : NFTCollectionDisplayView? = nil\n  if collectionDisplayView != nil {\n    nftCollectionDisplay = NFTCollectionDisplayView(\n      collectionName : collectionDisplayView!.name,\n      collectionDescription : collectionDisplayView!.description,\n      collectionSquareImage : collectionDisplayView!.squareImage.file.uri(),\n      collectionBannerImage : collectionDisplayView!.bannerImage.file.uri(),\n    )\n  }\n\n  var royalties : RoyaltiesView? = nil\n  if royaltyView != nil {\n    royalties = RoyaltiesView(\n      royalties : royaltyView!.getRoyalties()\n    )\n  }\n\n  return NFT(\n    id: testNftId,\n    display : display,\n    externalURL : externalURL,\n    nftCollectionData : nftCollectionData,\n    nftCollectionDisplay : nftCollectionDisplay,\n    royalties : royalties\n  ).getMapping()\n\n}","get_nft_metadata_for_collection_name":"import NFTCatalog from 0xNFTCatalog\n\npub fun main(collectionName: String): NFTCatalog.NFTCatalogMetadata? {\n  return NFTCatalog.getCatalogEntry(collectionName: collectionName)\n}","get_nft_proposal_for_id":"import NFTCatalog from 0xNFTCatalog\n\npub fun main(proposalID: UInt64): NFTCatalog.NFTCatalogProposal? {\n  return NFTCatalog.getCatalogProposalEntry(proposalID: proposalID)\n}","get_nfts_in_account":"import MetadataViews from 0xMetadataViews\nimport NFTRetrieval from 0xNFTRetrieval\n\npub struct NFT {\n  pub let id : UInt64\n  pub let name : String\n  pub let description : String\n  pub let thumbnail : String\n  pub let externalURL : String\n  pub let storagePath : StoragePath\n  pub let publicPath : PublicPath\n  pub let privatePath: PrivatePath\n  pub let publicLinkedType: Type\n  pub let privateLinkedType: Type\n  pub let collectionName : String\n  pub let collectionDescription: String\n  pub let collectionSquareImage : String\n  pub let collectionBannerImage : String\n  pub let royalties: [MetadataViews.Royalty]\n\n  init(\n      id: UInt64,\n      name : String,\n      description : String,\n      thumbnail : String,\n      externalURL : String,\n      storagePath : StoragePath,\n      publicPath : PublicPath,\n      privatePath : PrivatePath,\n      publicLinkedType : Type,\n      privateLinkedType : Type,\n      collectionName : String,\n      collectionDescription : String,\n      collectionSquareImage : String,\n      collectionBannerImage : String,\n      royalties : [MetadataViews.Royalty]\n  ) {\n    self.id = id\n    self.name = name\n    self.description = description\n    self.thumbnail = thumbnail\n    self.externalURL = externalURL\n    self.storagePath = storagePath\n    self.publicPath = publicPath\n    self.privatePath = privatePath\n    self.publicLinkedType = publicLinkedType\n    self.privateLinkedType = privateLinkedType\n    self.collectionName = collectionName\n    self.collectionDescription = collectionDescription\n    self.collectionSquareImage = collectionSquareImage\n    self.collectionBannerImage = collectionBannerImage\n    self.royalties = royalties\n  }\n}\n\npub fun main(ownerAddress: Address, collections: [String]) : { String : [NFT] }  {\n  let nftCollections = NFTRetrieval.getNFTs(ownerAddress : ownerAddress)\n  \n  let data : {String : [NFT] } = {}\n\n  for collection in collections {\n    if nftCollections.containsKey(collection) {\n      let nfts = nftCollections[collection]!\n      let items : [NFT] = []\n      \n      for nft in nfts {\n        let displayView = nft.display\n        let externalURLView = nft.externalURL\n        let collectionDataView = nft.collectionData\n        let collectionDisplayView = nft.collectionDisplay\n        let royaltyView = nft.royalties\n        if (displayView == nil || externalURLView == nil || collectionDataView == nil || collectionDisplayView == nil || royaltyView == nil) {\n          // Bad NFT. Skipping....\n          continue\n        }\n\n        items.append(\n          NFT(\n            id: nft.id,\n            name : displayView!.name,\n            description : displayView!.description,\n            thumbnail : displayView!.thumbnail.uri(),\n            externalURL : externalURLView!.url,\n            storagePath : collectionDataView!.storagePath,\n            publicPath : collectionDataView!.publicPath,\n            privatePath : collectionDataView!.providerPath,\n            publicLinkedType : collectionDataView!.publicLinkedType,\n            privateLinkedType : collectionDataView!.providerLinkedType,\n            collectionName : collectionDisplayView!.name,\n            collectionDescription : collectionDisplayView!.description,\n            collectionSquareImage : collectionDisplayView!.squareImage.file.uri(),\n            collectionBannerImage : collectionDisplayView!.bannerImage.file.uri(),\n            royalties : royaltyView!.getRoyalties()\n          )\n        )\n      }\n      \n      data[collection] = items\n    }\n  }\n\n  return data\n}","has_admin_proxy":"import NFTCatalogAdmin from 0xNFTCatalogAdmin\n\npub fun main(ownerAddress: Address) : Bool {\n  let owner = getAccount(ownerAddress)\n  let proxyCap = owner.getCapability<&{NFTCatalogAdmin.IAdminProxy}>(NFTCatalogAdmin.AdminProxyPublicPath)\n  return proxyCap.check()\n}","is_catalog_admin":"import NFTCatalogAdmin from 0xNFTCatalogAdmin\n\npub fun main(ownerAddress: Address) : Bool {\n  let owner = getAccount(ownerAddress)\n  let proxyCap = owner.getCapability<&{NFTCatalogAdmin.IAdminProxy}>(NFTCatalogAdmin.AdminProxyPublicPath)\n  if !proxyCap.check() {\n    return false\n  }\n  let proxyRef = proxyCap.borrow()!\n  return proxyRef.hasCapability()\n}"},"vars":{"emulator":{"0xNonFungibleToken":"0xf8d6e0586b0a20c7","0xMetadataViews":"0xf8d6e0586b0a20c7","0xFungibleToken":"0xee82856bf20e2aa6","0xFlowToken":"0x0ae53cb6e3f42a79","0xExampleNFT":"0xf8d6e0586b0a20c7","0xNFTCatalog":"0xf8d6e0586b0a20c7","0xNFTCatalogAdmin":"0xf8d6e0586b0a20c7","0xNFTRetrieval":"0xf8d6e0586b0a20c7"},"testnet":{"0xNonFungibleToken":"0x631e88ae7f1d7c20","0xMetadataViews":"0x631e88ae7f1d7c20","0xFungibleToken":"0x9a0766d93b6608b7","0xFlowToken":"0x7e60df042a9c0868","0xExampleNFT":null,"0xNFTCatalog":"0x0cb698d1315f5fa0","0xNFTCatalogAdmin":"0x0cb698d1315f5fa0","0xNFTRetrieval":"0x0cb698d1315f5fa0"},"mainnet":{"0xNonFungibleToken":"0x1d7e57aa55817448","0xMetadataViews":"0x1d7e57aa55817448","0xFungibleToken":"0xf233dcee88fe0abe","0xFlowToken":"0x1654653399040a61","0xExampleNFT":null,"0xNFTCatalog":null,"0xNFTCatalogAdmin":null,"0xNFTRetrieval":null}}}